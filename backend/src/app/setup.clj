;; This Source Code Form is subject to the terms of the Mozilla Public
;; License, v. 2.0. If a copy of the MPL was not distributed with this
;; file, You can obtain one at http://mozilla.org/MPL/2.0/.
;;
;; Copyright (c) KALEIDOS INC

(ns app.setup
  "Initial data setup of instance."
  (:require
   [app.common.data :as d]
   [app.common.logging :as l]
   [app.common.schema :as sm]
   [app.common.uuid :as uuid]
   [app.db :as db]
   [app.main :as-alias main]
   [app.setup.keys :as keys]
   [app.setup.templates]
   [buddy.core.codecs :as bc]
   [buddy.core.nonce :as bn]
   [integrant.core :as ig]))

(defn- generate-random-key
  []
  (-> (bn/random-bytes 64)
      (bc/bytes->b64-str true)))

(defn- get-all-props
  [conn]
  (->> (db/query conn :server-prop {:preload true})
       (filter #(not= "secret-key" (:id %)))
       (map (fn [row]
              [(keyword (:id row))
               (db/decode-transit-pgobject (:content row))]))
       (into {})))

(defn- handle-instance-id
  [instance-id conn read-only?]
  (l/info :hint "handle-instance-id")
  (l/info :instance-id instance-id)
  (l/info :conn conn)
  (l/info :read-only read-only?)
  (or instance-id
      (let [instance-id (uuid/random)]
        (when-not read-only?
          (try
            (db/insert! conn :server-prop
                        {:id "instance-id"
                         :preload true
                         :content (db/tjson instance-id)})
            (catch Throwable cause
              (l/warn :hint "unable to persist instance-id"
                      :instance-id instance-id
                      :cause cause))))
        instance-id)))


(def sql:add-prop
  "INSERT INTO server_prop (id, content, preload)
   VALUES (?, ?, ?)
       ON CONFLICT (id)
       DO UPDATE SET content=?, preload=?")

(defn get-prop
  ([system prop] (get-prop system prop nil))
  ([system prop default]
   (let [prop (d/name prop)]
     (db/run! system (fn [{:keys [::db/conn]}]
                       (or (db/get* conn :server-prop {:id prop})
                           default))))))

(defn set-prop!
  [system prop value]
  (let [value (db/tjson value)
        prop  (d/name prop)]
    (db/run! system (fn [{:keys [::db/conn]}]
                      (db/exec-one! conn [sql:add-prop prop value false value false])))))

(defmethod ig/assert-key ::props
  [_ params]
  (assert (db/pool? (::db/pool params)) "expected valid database pool"))

(defmethod ig/init-key ::props
  [_ {:keys [::db/pool ::key] :as cfg}]

  (db/tx-run! cfg (fn [{:keys [::db/conn]}]
                    (db/xact-lock! conn 0)

                    ;; Log before anything important happens
                    (l/info :hint "props-init-started"
                            :using-provided-key? (some? key)
                            :pool-exists? (some? pool))

                    (when-not key
                      (l/warn :hint (str "using autogenerated secret-key, it will change on each restart and will invalidate "
                                         "all sessions on each restart, it is highly recommended setting up the "
                                         "PENPOT_SECRET_KEY environment variable")))

                    (let [secret (or key (generate-random-key))]

                      ;; Log the secret we're actually using
                      (l/info :hint "secret-key-value"
                              :length (count secret)
                              :preview (subs secret 0 (min 20 (count secret)))
                              :is-autogenerated? (nil? key))

                      (let [base-props (get-all-props conn)

                            ;; Derive the specialized keys
                            tokens-key    (keys/derive secret :salt "tokens")
                            management-key (keys/derive secret :salt "management")

                            ;; Build final props
                            final-props (-> base-props
                                            (assoc :secret-key secret)
                                            (assoc :tokens-key tokens-key)
                                            (assoc :management-key management-key)
                                            (update :instance-id handle-instance-id conn (db/read-only? pool)))]

                        ;; === DEBUGGING BLOCK - most important part ===
                        (l/info :hint "props-dump-after-derivation"
                                :msg "=== FINAL PROPS STATE AFTER ALL MODIFICATIONS ==="
                                :keys-in-props (sort (keys final-props))
                                :has-secret-key? (contains? final-props :secret-key)
                                :secret-key-length (some-> final-props :secret-key count)
                                :has-tokens-key? (contains? final-props :tokens-key)
                                :tokens-key-type (some-> final-props :tokens-key type)
                                :tokens-key-exists? (some? (:tokens-key final-props))
                                :has-management-key? (contains? final-props :management-key)
                                :base-props-count (count base-props)
                                :instance-id-present? (contains? final-props :instance-id))

                        ;; Optional: more detailed dump (comment out in production)
                        #_(l/debug :hint "props-full-dump"
                                 :props (pr-str (into {} (map (fn [[k v]] [k (type v)]) final-props))))

                        ;; Return the final props map
                        final-props)))))

(sm/register! ::props [:map-of :keyword ::sm/any])
